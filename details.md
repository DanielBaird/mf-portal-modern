<link rel="stylesheet" href="https://cdn.jsdelivr.net/prism/1.4.1/themes/prism.css" />

<style>
  html {
    font-family: lato, sans-serif;
    font-size: 14pt;
    line-height: 1.5;
    background: white;
    padding: 0;
    margin: 0;
  }

  body {
    max-width: 50rem;
    margin: 0 auto;
    padding: 0 1rem 5rem;
  }

  img {
    max-width: 100%;
  }

  h1 {
    color: #f3f9ff;
    color; white;
    background: #357;
    line-height: 1.1;
    margin: 0 0 1rem;
    padding: 1em 0;
    box-shadow: -49.9rem 0 #357, 49.9rem 0 #357;
  }

h1, h2 {
  font-weight: 200;
  letter-spacing: -0.025em;
}

  h2, h3, h4, h5, h6 {
    color: #357;
    margin: 0 0 0 -0.1em;
    padding: 1.5em 0 0.5em;
  }
  h1 { font-size: 2.827rem; opacity: 1.00 }
  h2 { font-size: 3.998rem; opacity: 0.85 }
  /* not using 2.827rem */
  h3 { font-size: 1.999rem; opacity: 0.90 }
  h4 { font-size: 1.414rem; opacity: 0.95 }
  h5 { font-size: 1.000rem; opacity: 1.00 }
  h6 { font-size: 0.707rem; opacity: 1.00 }

  h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
    color: inherit;
    border-bottom: 2px dotted;
    text-decoration: inherit;
  }
  h1 a:hover, h2 a:hover, h3 a:hover, h4 a:hover, h5 a:hover, h6 a:hover {
    border-bottom: 2px solid;
  }

  p {
    margin: 0;
    padding: 0.33em 0;
  }

  code {
    font-size: smaller;
  }

  p > code {
    background: #f3f9ff;
    padding: 0.3em;
    border-radius: 0.3em;
  }

  pre {
    padding: 0.5em;
    background: #f3f9ff;
    border-left: 1px solid #eef0ff;
    box-shadow: -50rem 0 #f3f9ff, 50rem 0 #f3f9ff;
  }

  pre.small { font-size: 75%; color: rgba(0,0,0, 0.8) }

  /* override some Prism sourcecode highlight styles */
  pre[class*="language-"] {
    line-height: 1.2;
    overflow: visible;
    background: #f3f9ff;
  }
  :not(pre) > code[class*="language-"] {
    background: #f3f9ff;
    padding: 0.3em;
    border-radius: 0.3em;
  }

  code[class*="language-"] {
    line-height: 1.2;
  }

  pre p {
    padding: 0;
  }


  /* ToC management */
  #tocHeading { cursor: pointer; }
  #tocContent { overflow: hidden; font-size: smaller; }
  .open   #tocHeading:after { content: ' \25be' }
  .closed #tocHeading:after { content: ' \25b8' }
  .open   #tocContent { height: auto; }
  .closed #tocContent { height: 0; }

</style>

# Revising MediaFlux Portal output


## What's in this repo


### original HTML

[`original-gwt-html`](original-gwt-html) directory contains raw
html generated by the current portal plugin, for several Cat Portal
pages including the cat list page.


### Componentised versions

[`html-components`](html-components) directory contains three
componentised versions of the cat list page.

The components extracted are indicated in this diagram:

![components](images/components-01.png)

These are my guesses at page entities managed by the GWT code.

Each of the three componentised versions includes a `cat-list.source`
file that contains the page layout and shows where to include the
component files.  A shell script `convert.sh` (for
[bash](https://en.wikipedia.org/wiki/Bash_(Unix_shell))) inserts the
component files into the right places, to produce
`cat-list.source.html` which is the complete page (this output
is aready in the repo, so you don't need to run the script to see the
result).


#### Original version, split into components

[Original version demo](http://danielbaird.com/mf-portal-modern/html-components/old/cat-list.source.html)

[`html-components/old`](html-components/old) contains the
original GWT generated HTML, split across several files.  The HTML
is not changed from GWT's generated code, aside from splitting out
components, and a minor path tweak to the Font Awesome path so that
it continues to work without a MF server.

HTML for each component is in the
[`./components`](html-components/old/components) directory.


#### New version, revising component structure

[New version demo](http://danielbaird.com/mf-portal-modern/html-components/new/cat-list.source.html)

[`html-components/new`](html-components/new) contains the same
files as the componentised original version, but with new content.

New HTML for each component is in the
[`./components`](html-components/new/components) directory.

E.g here is the HTML built by GWT for the menu bar:

<pre class="language-markup"><code>
&lt;table cellspacing="0" cellpadding="0" class="arc_11_base_widget_1  style_22" style="height: 40px; width: 1143px;">
    &lt;tbody>
        &lt;tr>
            &lt;td align="left" style="vertical-align: top;">
                &lt;div class="arc_11_base_widget_1 arc_12_SimplePanel" style="width: 722px;">&lt;/div>
            &lt;/td>
            &lt;td align="left" style="vertical-align: top;">
                &lt;table cellspacing="0" cellpadding="0" class="arc_11_base_widget_1" style="height: 40px; margin-right: 94px;">
                    &lt;tbody>
                        &lt;tr>
                            &lt;td align="left" style="vertical-align: middle;">
                                &lt;div class="arc_11_base_widget_1 arc_15_PortalGUI_MenuItem" style="cursor: default;">Collections&lt;/div>
                            &lt;/td>
                            &lt;td align="left" style="vertical-align: middle;">
                                &lt;div class="arc_11_base_widget_1 arc_15_PortalGUI_MenuItem" style="cursor: default;">Breeds&lt;/div>
                            &lt;/td>
                            &lt;td align="left" style="vertical-align: middle;">
                                &lt;div class="arc_11_base_widget_1 arc_15_PortalGUI_MenuItem" style="cursor: default;">FAQ&lt;/div>
                            &lt;/td>
                            &lt;td align="left" style="vertical-align: middle;">
                                &lt;div class="arc_11_base_widget_1 arc_15_PortalGUI_MenuItem" style="cursor: default;">About&lt;/div>
                            &lt;/td>
                        &lt;/tr>
                    &lt;/tbody>
                &lt;/table>
            &lt;/td>
        &lt;/tr>
    &lt;/tbody>
&lt;/table>
</code></pre>

It's a single row table with two cells; empty space in the left cell,
and the right cell contains another single row table that has a cell
for each menu item.

Here's the revised HTML for the menu component:

<pre class="language-markup"><code>
&lt;nav class="mf-portal-navbar">
    &lt;ul class="mf-nav-list">
        &lt;li class="mf-nav-item">&lt;a href="">Collections&lt;/a>&lt;/li>
        &lt;li class="mf-nav-item">&lt;a href="">Breeds&lt;/a>&lt;/li>
        &lt;li class="mf-nav-item">&lt;a href="">FAQ&lt;/a>&lt;/li>
        &lt;li class="mf-nav-item">&lt;a href="">About&lt;/a>&lt;/li>
    &lt;/ul>
&lt;/nav>
</code></pre>

It's a nav element containing an unordered list, and each thing in
the list is a menu item.

Compared to the old source, this uses:

- **semantically accurate tags**: `nav` for navigation, `ul` and
  `li` for a list of items
- **no fixed sizes** so the client browser can adjust content size
  to fit the viewport without using JavaScript size-change detectors
- **sensible CSS class names** so MediaFlux nodes can supply their
  own presentation settings via CSS, and interrogate the page with
  their own JavaScript
- **no hard-coded styles** such as `style="vertical-align: middle;"`
  which cannot be overridden by CSS


#### New version, alternate styling

[Alternate version demo](http://danielbaird.com/mf-portal-modern/html-components/new/cat-list-alt.source.html)

The utility of this more semantically correct document structure is
the ability for MediaFlux nodes to apply their own styling.  To
demonstrate this, I've used the indentical HTML from the new version,
and replaced the CSS.

This new CSS styling took less than a day to write, and it allows a
substantially different look.  For maximum impact I focussed on a
dramatic visual change, but this same technique will allow nodes to
build portal layouts that work properly on tiny screens, or giant
wall-mounted dashboards.



<script src="https://rawgit.com/gajus/contents/master/dist/browser/contents.js"></script>
<script>
  // make a ToC with all the headings
  var c = gajus.Contents({
    articles: document.querySelectorAll('h2, h3, h4, h5, h6')
  });

  // put the ToC into a open-close container
  var toc = document.createElement('div')
  toc.className = 'closed'
  toc.innerHTML = '<h3 id="tocHeading" title="click to show/hide">Contents</h3><div id="tocContent"></div>'

  // find the first h2 and put the ToC right before it
  var firstHeading2 = document.querySelector('h2')
  firstHeading2.parentNode.insertBefore(toc, firstHeading2)
  document.getElementById('tocContent').insertBefore(c.list(), null)

  // rig the heading to show/hide the ToC by switching classes
  document.getElementById('tocHeading').addEventListener("click", function() {
    if (toc.className === 'closed') {
      toc.className = 'open'
    } else {
      toc.className = 'closed'
    }
  })
</script>
<script src="https://cdn.jsdelivr.net/prism/1.4.1/prism.js"></script>


## What to do next

Here are some steps for getting the portal plugin producing this
theoretical better output.

- Make an **index of components** -- rather than me guessing the set
of components, an Architecta person can go through the existing
portal page description code and make a list.  Roughly each
component's use / operating context / edge cases.
- For each component in the index, **work out the HTML** that should
be generated to represent that component.  Handle any special cases.
Be clear enough that users can write JavaScript interactions finding
and manipulating page elements.
- Work out a predictible way to include JavaScript-discoverable data
in the page.  `data-*` attributes, `template` or
[`script`](https://developer.mozilla.org/en/docs/Using_XML_Data_Islands_in_Mozilla)
tags..
- Over the set of components, work out a consistent and useful list
of CSS classes.  The simplest arrangement would be a single unique
class for every component, but it may be worth using category
labels like "mediaflux-button" so CSS authors can address all
buttons.
- Work out how much of the current portal XML definition can just
be deleted, and if anything that remains needs to be changed.
- Work out how to get GWT to generate the imagined HTML, e.g. switch
to FlowPanel instead of Horizontal/VerticalPanel.  Pragmatically
adjust to suit -- if there's no way to get a `nav` tag, it's fine to
use a `div`.
- Create a CSS stylesheet that makes a reasonable default portal
layout. This *could* look like the cats portal if that's deemed
desirable. Potentially MediaFlux could ship with a couple of options
for portal styling (which would also help get users started with
writing their own CSS).
- Work out how to deliver user-defined CSS and JavaScript for a
given portal. Assets in a special namespace?  Assets from anywhere,
identified via direct paths in the portal xml?











